<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[yolo的原理和实现]]></title>
    <url>%2F2019%2F09%2F09%2Fyolo%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[SSD原理与实现]]></title>
    <url>%2F2019%2F09%2F08%2FSSD%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[R-FCN学习及理解]]></title>
    <url>%2F2019%2F09%2F08%2FR-FCN%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.贡献 提出Position-sensitive score maps来解决目标检测的位置敏感性问题 区域为基础，全卷积网络的two-state目标检测框架 比faster-rcnn快2.5-20倍 2.R-FCN与传统two-state网络的异同点Faster R-rcnn是首个利用CNN来完成proposals的预测 Fully Convolution subnetwork before RoI layer RoI-wise subnetwork 1.第一部分直接用普通分类的卷积层，用来提取共享特征，然后一个ROI pooling layer在第一部分的最后一张特征图上进行提取针对各个Rois的特征向量，然后将所有Rois的特征向量，交由第二部分来处理（分类和回归）。 2.第二部分一部都是全连接层，在最后有2个并行的loss函数：softmax和smoothL1，分别用来对每一个Roi进行回归和分类。这样就可以的得到每个ROi的真实类别和较为精确的坐标和长宽了。 注意：rois是共享所有由基础分类网络生成的feature maps，而第二部分的Roi-wise subnetwork，它却不是所有Rois共享的，因为这一部分的就是给每个ROi进行分类和回归，所以不能共享计算。首先问题就在于，第一部分的网络具有“位置不敏感性”–平移的不变性。我的疑惑，translation-invariance代表什么，是指卷积网络是具有位置信息，但是全连接层是没有位置信息的？ resnet论文解决方法：roi pooling layer不再放在卷积层和全连接之间，而是放在卷积层之间，样RoI Pooling Layer之前和之后都有卷积层，并且RoI Pooling Layer之后的卷积层不是共享计算的，它们是针对每个RoI进行特征提取的，所以这种网络设计，其RoI Pooling Layer之后就具有了“位置敏感性translation-variance”缺点：测试速度很慢。 3.RFC网络设计设计思路：如果一个Roi含有一个类别c的物体，那么作者就将该ROi分类k*k个区域，分别表示该物体的各个部位例子: 假设Roi中含有人这个物体，k=3，那么将”人” 划分为9个子区域，而将Roi划分为k^2个区域是希望这个Roi在其中的每一个区域都应该含有该类别c的物体的各个部位。当所有子区域都含有各自对应的该物体相应部位后，那么分类器才会判断为该类别。物体的各个部位和roi的子区域是映射关系。我的疑惑：如何判断该子区域为该类别呢？ 4.position-sensitive score mapposition-sensitive score map设计的核心思想：判断RoI子区域是否含有物体的相应部位”R-FCN会在共享卷积层的最后再接上一层卷积层，而该卷积层就是“位置敏感得分图position-sensitive score map” score maps的意义：它就是一层卷积层，它的height和width和共享卷积层的一样，但是它的channels= k^2(C+1),那么C表示物体类别种数再加上1个背景类别，每个类别都有 k^2个score maps。每个score maps表示原图image中的哪些位置含有人的某一个部位，而每一个score map表示该score map对应的人体的某个部位有”高响应值”，也就是说每一个score map都是用来“描述人体的其中一个部位出现在该score map的何处，而在出现的地方就有高响应值”。 5.Position-sensitive RoI poolingpooling layer的作用：就是在该bin对应的score map上的子区域执行，且执行的是平均池化。第i个bin对应的第i个score map上找响应值，那么也就是在第i个score map上的“该第i个bin对应的位置”上进行池化操作，且池化是取“bin这个范围内的所有值的平均值”。对于每个类别，它都有k^2个score maps，那么对于每个类别，该类别的k^2个值都表示该RoI属于该类别的响应值，那么将这k^2个数相加就得到该类别的score，那么一共有C+1个scores，那么将这C+1个数使用简单的softmax函数就可以得到属于各个类别的概率了 6.position-sensitive regression在ResNet的共享卷积层的最后一层上，接上一个与position-sensitive score map并行的（sibling）score maps，该score maps用于regression，暂且命名为“regression score map”，而该regression score map的维度应当是4k^2 ,那么在经过Position-sensitive RoI pooling操作后，每一个RoI就会得到第4个数作为“该RoI的坐标和长宽的偏移量”了。 7.网络的训练根据网络的loss公式，如果一个RoI含有人这个物体，那么该RoI通过“position-sensitive score map”+“Position-sensitive RoI pooling”得到的 [公式] 个值中的属于人的那个值必然会在softmax损失函数的要求下“变得尽量的大”，那么如何才能使得属于人的这个值尽量的大呢？那么我们现在就要想到，属于人的这个预测值是怎么来的？在前面的分析，我们已经知道它是通过Position-sensitive RoI pooling这种池化操作的来的，那么也就是说使得 [公式] 个值中属于人的那个值尽量大，必然会使得position-sensitive score map中属于人的那个score map上的“该RoI对应的位置区域的平均值”尽量大，从而也就是该score map上在该区域上的响应值尽量大，因为只有该区域的响应值大了，才能使得预测为人的概率大，才会降低softmax的loss。 使用如上的损失函数，对于任意一个RoI，计算它的softmax损失，和“当其不属于背景时的回归损失”。这很简单，因为每个RoI都被指定属于某一个GT box或者属于背景，即先让GT box选择与其IoU最大的那个RoI，然后再对剩余RoI选择与GT box的IoU&gt;0.5的进行匹配，而剩下的RoI全部为背景类别。那么RoI有了label后，loss自然很容易计算出来。 而唯一不同的就是，为了减少计算量，作者将所有RoIs的loss值都计算出来后，对其进行排序，并只对“最大的128个损失值对应的RoIs”执行反向传播操作，其它的则忽略。并且训练策略也是采用的Faster R-CNN中的4-step alternating training进行训练。 在测试的时候，为了减少RoIs的数量，作者在RPN提取阶段就将RPN提取的大约2W个proposals进行过滤： 去除超过图像边界的proposals使用基于类别概率且阈值IoU=0.7的NMS过滤按照类别概率选择top-N个proposals所以在测试的时候，一般只剩下300个RoIs，当然这个数量是一个超参数。并且在R-FCN的输出300个预测框之后，仍然要对其使用NMS去除冗余的预测框。 其他 trous 技巧作者将最后1个池化层的步长从2减小到1，那么图像将从缩小32倍变成只缩小16倍，这样就提高了共享卷积层的输出分辨率。而这样做就要使用Atrous Convolution算法，具体参见论文Semantic Image Segmentation With Deep Convolutional Nets and Fully Connnected CRFS 输入Image的RoI是如何映射到position-sensitive score map上的？因为RoI的坐标应该相对于原始image的真实坐标，而Position-sensitive RoI pooling的池化操作却是利用RoI在position-sensitive score map上完成的，那么现在就必须有一个映射关系将输入image上的RoI映射到position-sensitive score map上，大致映射见下图（详情可参见原始图片中的ROI如何映射到到feature map?）：]]></content>
      <categories>
        <category>目标检测与识别</category>
      </categories>
      <tags>
        <tag>全卷积</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FCN的学习及理解]]></title>
    <url>%2F2019%2F09%2F08%2FFCN%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"></content>
      <categories>
        <category>目标检测与识别</category>
      </categories>
      <tags>
        <tag>语义分割</tag>
        <tag>全卷积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入坑java开发的自学之路]]></title>
    <url>%2F2019%2F09%2F05%2F%E5%85%A5%E5%9D%91java%E5%BC%80%E5%8F%91%E7%9A%84%E8%87%AA%E5%AD%A6%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[基础知识 编程语言：java、python、c 基本算法 基本网络知识：TCP/IP HTTP/HTTPS 基本设计模式 工具方面 操作系统：linux （centos/ubuntu\） 代码管理：git 持续集成：jenkins java的项目管理工具：Maven / Gradle 框架方面应用层框架 ssh spring + structs + hibernate ssm：spring springmvc mybatis spring boot 各种中间件 MQ 消息队列 RPC 通信框架 elasticsearch 数据库 搜索引擎 数据库 SQL: MySQL / postgre SQL NoSQL： Redis Menmcached mongodb 架构方面分布式/微服务架构 spring cloud dubbo rpc通信 虚拟化/容器化的技术 docker 容器化 K8S kubernetes 关于源码/性能 JDK源码以及部分设计思想 spring源码 jvm 细节与排错 高并发/高可用 书籍 java编程思想 java 并发编程实战 深入理解java虚拟机 函数式变成思维 tcp/ip详解 卷1 鸟哥linux私房菜]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next主题设置]]></title>
    <url>%2F2019%2F09%2F05%2FNext%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[搜索功能安装插件npm install hexo-generator-searchdb –save修改 站点配置 文件 12345search: path: search.xml field: post format: html limit: 10000 修改 主题配置文件 12local_search: enable: true]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo操作]]></title>
    <url>%2F2019%2F09%2F05%2Fhexo%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[hexo操作 hexo help # 查看帮助 hexo version #查看Hexo的版本 hexo algolia # 更新search庫 hexo new “postName” #新建文章 hexo new post “title” # 生成新文章：\source_posts\title.md，可省略post hexo new page “pageName” #新建页面 hexo clean #清除部署緩存 hexo n == hexo new #新建文章 hexo g == hexo generate #生成静态页面至public目录 hexo s == hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo d == hexo deploy #将.deploy目录部署到GitHub hexo d -g #生成加部署 hexo s -g #生成加预览 部署每次部署的步骤，可按以下两部来进行 hexo cl hexo d -g 添加分类创建分类选项打开命令行，进入博客所在文件夹。执行命令 1hexo new page categories 成功后会提示： 1INFO Created: ~/Documents/blog/source/categories/index.md 根据上面的路径，找到index.md这个文件，添加type: “categories”到内容中，添加后是这样的： 123title: 文章分类date: 2017-05-27 13:47:40type: &quot;categories&quot; 给文章添加“categories”属性打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 123456---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories:- web前端--- 至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。 标签生成“标签”页并添加tpye属性打开命令行，进入博客所在文件夹。执行命令 1hexo new page tags 根据上面的路径，找到index.md这个文件，添加type: “tags”到内容中，添加后是这样的： 12345---title: 文章分类date: 2017-05-27 13:47:40type: &quot;tags&quot;--- 给文章添加“tags”属性打开需要添加标签的文章，为其添加tags属性。 123456789---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories:- web前端tags:- jQuery- 表格---]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown基本语法和操作]]></title>
    <url>%2F2019%2F09%2F05%2Fmarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[markdown基本语法和操作一、基本语法1.1 字体大小、颜色、类型、加粗、倾斜、删除123456&lt;font size=5&gt; Hello&lt;br&gt;&lt;font color=red&gt;color&lt;br&gt;&lt;font face=&quot;微软雅黑&quot;&gt;微软雅黑&lt;br&gt;**内容** 加粗&lt;br&gt;*内容* 倾斜&lt;br&gt;~~内容~~ 1.2 标题通过在文字前面添加#即可 123# 一级标题## 二级标题### 三级标题 1.3 超链接12[超链接名](超链接地址)[baidu](http://baidu.com) 1.4 插入图片12[图片描述](图片链接)![avatar](http://baidu.com/pic/doge.png) 1.5、代码块12int a = 0system.out.println(&quot;Hello&quot;); 1.6 引用在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。 1.7分割线123三个或者三个以上 - 或者 ****--- 1.8 列表无序列表 12- 使用 *，+，- 表示无序列表。- 注意：符号后面一定要有一个空格，起到缩进的作用。 有序列表 12使用数字和一个英文句点表示有序列表。注意：英文句点后面一定要有一个空格，起到缩进的作用。 注意事项 1在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。 1.9 表格12345学号|姓名|分数-|-|-小明|男|75注意：表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。 学号 姓名 分数 小明 男 75 二、常用技巧2.1 换行1html语言换行标签：&lt;br&gt; 2.2 缩进字符&#160;你好&#8194;你好&#8195;你好你好 123&amp;#160;你好 缩进1/4 中文&amp;#8194;你好 缩进半个中文，1个字符&amp;#8195;你好 缩进一个中文，2个字符 特殊符号对于 Markdown 中的语法符号，前面加反斜线\即可显示符号本身。 如何让博文列表不显示全部内容默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？答案是在合适的位置加上即可 三、latex数学公式]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github配置]]></title>
    <url>%2F2019%2F09%2F04%2Fhexo-github%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo部署github博客一、简介Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo能够快速生成博客和部署博客，使创建博客更加简单。 二、安装步骤1.搭建环境准备：node.js和git环境，gitHub账户的配置2.安装Hexo3.配置Hexo4.怎么将Hexo与github page联系5.怎么发布文章6.主题 推荐7.主题Net的简单配置8.添加sitemap和feed插件9.添加404公益页面 搭建环境准备 Node.js 的安装和准备 git 的安装和准备 github账户的配置 配置Node.js 环境 下载Node.js 安装文件 安装完后，打开cmd，在打开的命令行界面中，输入12Node -vnpm -v 配置Git环境 安装git 同样，打开命令行界面检查是否安装正确，输入：1git --version gitHub账户的配置 已有，跳过 创建代码库，在repository name下填写 yourname.github.io注意：比如我的github名称是gdutxiaoxu ,这里你就填 gdutxiaoxu.github.io,如果你的名字是xujun，那你就填 xujun.github.io hexo安装 在自己认为合适的地方创建一个文件夹，这里我以E：/hexo 为例子讲解，首先在E盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录 在命令行输入： 1npm install hexo-cli -g 然后继续输入： 1npm install hexo --save hexo的相关配置 初始化hexo,继续上述操作： 12hexo initnpm install hexo生成和部署 12hexo g 生成hexo s 打开blog hexo与github page 联系起来大致分为一下几步： 配置git个人信息 配置deployment配置git个人信息 设置Git的user name和email：(如果是第一次的话)： 12git config --global user.name &quot;chanchanchanhhh&quot;git config --global user.email &quot;dzumin@hotmail.com&quot; 生成密钥 1ssh-keygen -t rsa -C &quot;gdutxiaoxu@163.com&quot; 打开github setting, 选择ssh密钥，添加密钥，并打开id_rsa文件将密钥复制并粘贴在描述栏。 配置Deployment1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 安装一个扩展 1npm install hexo-deployer-git --save Net主题的配置在 Hexo 中有两份主要的配置文件，其名称都是_config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。1.安装NextHexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。具体到 NexT 来说，安装步骤如下。 在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 2.启用主题 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。1theme: next]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
